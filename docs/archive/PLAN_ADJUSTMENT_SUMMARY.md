# 开发计划调整总结

## 📅 调整时间
2025-11-04

## 🎯 调整原因

用户明确表示：
> "此项目就是想自己用rust实现类似rocksdb的存储引擎，所以我希望在自研的存储引擎上避免rocksdb的问题，并且拥有rocksdb中的优势"

## 📊 调整前后对比

### 原计划（IMPLEMENTATION_PLAN.md）

**特点**：
- 14个阶段，全面覆盖
- 完整的功能列表
- 详细的技术规格
- 预计2-3个月完成

**问题**：
- 阶段划分过细，缺乏优先级
- 没有明确指出如何借鉴RocksDB
- 缺少与RocksDB的对比分析
- 可能陷入过度设计

### 新计划（OPTIMIZED_PLAN.md）

**特点**：
- 3个阶段：MVP(4-6周) → 优化(6-8周) → 生产(4-6周)
- 明确每阶段的目标和范围
- 清晰的简化策略
- 渐进式验证

**优势**：
- ✅ 快速验证核心架构（4-6周MVP）
- ✅ 明确借鉴RocksDB的具体内容
- ✅ 清晰说明避免的复杂性
- ✅ 务实的性能目标

## 📚 新增文档说明

### 1. OPTIMIZED_PLAN.md ⭐ **主要计划**

**内容**：
- 三阶段实施路线
- 从RocksDB借鉴的8个优点
- 避免RocksDB的6个问题
- 详细的阶段A实施计划（Day by Day）
- 关键设计决策
- 性能目标

**适合**：
- 实际开发执行
- 了解开发路线
- 理解设计权衡

### 2. ROCKSDB_LESSONS.md ⭐ **设计理念**

**内容**：
- ✅ 从RocksDB借鉴什么（8个方面）
  - LSM架构、WAL设计、Bloom Filter等
- ❌ 避免RocksDB什么（6个方面）
  - 配置复杂、API臃肿、特性膨胀等
- 📊 详细对比和代码示例
- 🎯 实施建议

**适合**：
- 理解设计思路
- 学习技术决策
- 代码实现参考

### 3. IMPLEMENTATION_STRATEGY.md ⭐ **策略总览**

**内容**：
- 文档导航指南
- 当前阶段说明
- 开发流程和最佳实践
- 里程碑和成功标准
- 新人学习路径

**适合**：
- 项目全局了解
- 新人入门
- 任务分配

### 4. IMPLEMENTATION_PLAN.md（保留）

**说明**：
- 保留作为详细技术参考
- 包含完整的14阶段规划
- 可作为长期技术规格文档

## 🎯 核心调整要点

### 1. 明确"借鉴什么"

| RocksDB优点 | 如何借鉴 | 阶段 |
|-----------|---------|------|
| LSM分层架构 | 完全采用 | A |
| WAL格式设计 | 简化版实现 | A |
| SkipList MemTable | 使用crossbeam-skiplist | A |
| 分块SSTable | 简化版（无压缩） | A |
| Leveled Compaction | 完整实现 | B |
| Bloom Filter | 完整实现 | B |
| Block Cache | LRU实现 | B |
| WriteBatch | 完整实现 | B |

### 2. 明确"避免什么"

| RocksDB问题 | AiDb解决方案 | 效果 |
|-----------|------------|------|
| 配置项200+ | 简化到<20个 | 易用性↑ |
| API方法100+ | 简化到<30个 | 学习曲线↓ |
| 200K行C++代码 | 目标<10K行Rust | 可维护性↑ |
| 编译10+分钟 | 编译<2分钟 | 开发效率↑ |
| Column Families | 不实现 | 复杂度↓ |
| 复杂事务 | 简化Snapshot | 复杂度↓ |

### 3. 三阶段渐进式实施

```
阶段A (4-6周): MVP
├─ 目标: 验证核心架构
├─ 范围: WAL + MemTable + SSTable + 基础Flush
├─ 性能: 15-20% RocksDB（可接受）
└─ 简化: 无Compaction、无压缩、无缓存

阶段B (6-8周): 优化
├─ 目标: 接近实用性能
├─ 新增: Compaction + Bloom Filter + Cache + 压缩
├─ 性能: 50-60% RocksDB（实用）
└─ 优化: 多线程、批处理

阶段C (4-6周): 生产就绪
├─ 目标: 生产级稳定性
├─ 新增: Snapshot + 完整Iterator + 监控
├─ 性能: 60-70% RocksDB（生产可用）
└─ 完善: 测试、文档、工具
```

### 4. 明确的性能预期

**阶段性目标**：
```
阶段A: 15-20% RocksDB性能
  └─ 重点: 功能正确性

阶段B: 50-60% RocksDB性能
  └─ 重点: 核心优化

阶段C: 60-70% RocksDB性能
  └─ 重点: 稳定性和完整性
```

**理由**：
- 务实的目标，不追求100%
- 70%性能对大部分场景已足够
- 避免过度优化的陷阱

## 🚀 立即行动

### 当前优先级

**P0 - 本周开始**：
```bash
Day 1-2:   确认项目结构，设置测试框架
Day 3-5:   实现WAL (简化版)
Day 6-9:   实现MemTable (使用crossbeam-skiplist)
Day 10-14: 实现SSTable基础 (无压缩、无BF)
```

**关键决策**：
1. ✅ 使用crossbeam-skiplist（不自己实现）
2. ✅ WAL使用简化的RocksDB格式
3. ✅ SSTable暂不实现压缩和Bloom Filter
4. ✅ 单线程Flush（后续优化）

### 开发方式

**测试驱动开发**：
```rust
// 1. 先写测试
#[test]
fn test_wal_recovery() {
    let wal = WAL::new("test.log")?;
    wal.append(b"key", b"value")?;
    drop(wal);
    
    let wal2 = WAL::open("test.log")?;
    let records = wal2.recover()?;
    assert_eq!(records.len(), 1);
}

// 2. 再实现功能
impl WAL {
    pub fn append(&mut self, key: &[u8], value: &[u8]) -> Result<()> {
        // 实现...
    }
}

// 3. 运行测试验证
cargo test test_wal_recovery
```

**持续验证**：
- 每个组件完成后立即测试
- 集成测试验证端到端功能
- 性能基准测试跟踪性能

## 📖 文档使用指南

### 对于开发者

**第1天**：
1. 阅读 `PLAN_ADJUSTMENT_SUMMARY.md`（本文档）
2. 阅读 `OPTIMIZED_PLAN.md` 了解三阶段计划
3. 阅读 `ROCKSDB_LESSONS.md` 理解设计理念

**第2-3天**：
1. 阅读 `IMPLEMENTATION_STRATEGY.md` 了解开发流程
2. 浏览 `IMPLEMENTATION_PLAN.md` 了解技术细节
3. 查看现有代码（src/目录）

**第4天开始**：
1. 从TODO.md认领任务
2. 参考OPTIMIZED_PLAN.md的Day-by-Day计划
3. 编码 → 测试 → 提交

### 对于技术决策

**需要了解"为什么这样设计"**：
→ 阅读 `ROCKSDB_LESSONS.md`

**需要了解"具体怎么实现"**：
→ 阅读 `OPTIMIZED_PLAN.md` 和 `IMPLEMENTATION_PLAN.md`

**需要了解"当前做什么"**：
→ 查看 `TODO.md` 和 `IMPLEMENTATION_STRATEGY.md`

## ✅ 调整验证标准

### 计划是否成功？

**4-6周后检查**：
- [ ] MVP能否运行基础读写？
- [ ] 崩溃恢复是否正常？
- [ ] 性能是否达到15-20%目标？
- [ ] 代码是否清晰易懂？

**12-14周后检查**：
- [ ] 性能是否达到50-60%目标？
- [ ] Compaction是否正常工作？
- [ ] 是否有Block Cache和Bloom Filter？
- [ ] 并发测试是否通过？

**18-20周后检查**：
- [ ] 所有功能是否完整？
- [ ] 测试覆盖率是否>80%？
- [ ] 性能是否达到60-70%目标？
- [ ] 文档是否完善？

## 🎓 关键经验

### 从RocksDB学到的

1. **架构设计**
   - LSM-Tree分层是经过验证的好设计
   - WAL + MemTable + SSTable的经典组合
   - Compaction是性能关键

2. **性能优化**
   - Bloom Filter能减少80%+无效读取
   - Block Cache对热数据至关重要
   - 批量写入显著提升吞吐

3. **工程实践**
   - CRC32校验保证数据完整性
   - 后台线程异步处理Compaction
   - 读写分离提升并发性能

### 要避免的陷阱

1. **过度设计**
   - ❌ 不需要Column Families
   - ❌ 不需要复杂的事务模型
   - ✅ 先实现核心功能

2. **完美主义**
   - ❌ 不追求100%性能
   - ❌ 不实现所有RocksDB特性
   - ✅ 70%性能对大部分场景够用

3. **盲目复制**
   - ❌ 不照搬RocksDB的C++代码
   - ❌ 不采用RocksDB的复杂配置
   - ✅ 理解原理，用Rust的方式实现

## 📝 后续跟踪

### 定期review

**每2周**：
- 回顾进度
- 评估是否需要调整
- 更新文档

**每个阶段完成后**：
- 全面评估
- 决定下一步
- 可能调整计划

### 持续改进

随着开发深入：
- 更新设计文档
- 补充实现细节
- 记录踩过的坑
- 分享经验教训

## 🎯 成功标准（再次明确）

### 技术层面

- ✅ **功能完整**：基础CRUD + 崩溃恢复
- ✅ **性能合格**：达到RocksDB 60-70%
- ✅ **代码清晰**：易于理解和维护
- ✅ **测试完善**：覆盖率>80%

### 工程层面

- ✅ **编译快速**：<2分钟
- ✅ **无C++依赖**：纯Rust
- ✅ **易于使用**：简洁API
- ✅ **文档完整**：API + 示例 + 指南

### 实用层面

- ✅ **能跑**：4-6周后有MVP
- ✅ **能用**：12-14周后接近实用
- ✅ **好用**：18-20周后生产就绪

## 总结

### 这次调整解决了什么？

1. **明确了借鉴方向**
   - 从RocksDB学习8个核心优点
   - 避免RocksDB的6个主要问题
   - 清晰的技术决策依据

2. **优化了实施路径**
   - 三阶段渐进式实施
   - 每个阶段都能验证价值
   - 降低风险，快速迭代

3. **设定了务实目标**
   - 不追求100%功能对等
   - 60-70%性能已经够用
   - 简化API和配置

4. **保持了纯Rust方向**
   - 自研实现，完全控制
   - 无C++依赖
   - 利用Rust优势

### 下一步

**立即开始阶段A开发**！

参考 `OPTIMIZED_PLAN.md` 的 Day 3-5 开始实现WAL。

---

**期待4-6周后的MVP！** 🚀

*最后更新: 2025-11-04*
